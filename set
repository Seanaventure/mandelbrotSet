from threading import Thread
from PIL import Image, ImageDraw
import math
import time

# Constants for the colors
black = (0, 0, 0)
blue = (0, 0, 153)
red = (255, 0, 0)
lightBlue = (102, 178, 255)
turqoise = (0, 255, 255)
purple = (255, 0, 255)
orange = (255, 102, 0)
maroon = (153, 0, 0)

# Dimensions of the image
dimX = 1024
dimY = 1024
threadIncrement = dimX // 8

# Essentially the 'Window' of the program
xMax = -.65
xMin = -1.35

yMax = 0.35
yMin = -0.35

# Used to keep track of how many calculations are made
iterations = 0

# Used to calculate the actual value of each pixel on the complex plane
intervalX = (-xMin + xMax)/dimX
intervalY = (-yMin + xMax)/dimY

# Creates an empty list with 64 spaces for images
values = [Image.new('RGB', (dimY//8, dimX//8)) for i in range(64)]
# Keeps track of threads
threads = []


def main():
    print("Starting Mandlebrot")
    # Creating the image and opening the drawing
    im = Image.new('RGB', (dimX, dimY))
    time0 = time.time()
    threadCount = 1
    for i in range(0, dimX, threadIncrement):
        for j in range(0, dimY, threadIncrement):
            newThread = Thread(target=calcSection, args=((j, i), threadIncrement, threadCount))
            threads.append(newThread)
            newThread.start()
            threadCount += 1
    for i in range(len(threads)):
        threads[i].join()
        y = (i // 8)
        x = (i - (8 * y))
        im.paste(values[i], (x * threadIncrement, y * threadIncrement))
    time1 = time.time()
    totalTime = time1 - time0
    print("Drawing took " + str(totalTime) + " seconds")
    print("Did " + str(iterations) + " calculations")
    im.save("mandlebrot1.png")


def calcSection(coords, increment, threadNum):
    im = Image.new('RGB', (increment, increment))
    draw = ImageDraw.Draw(im, 'RGB')
    for i in range(increment):
        for j in range(increment):
            draw.point((i, j), startCalculation(getC(coords[0] + i, coords[1] + j)))
    draw.text((0, 0), "({} + {}i".format(getC(coords[0], coords[1])[0], getC(coords[0], coords[1])[1]))
    del draw
    values[threadNum-1] = im


def getC(x, y):
    """
    Finds out what the value of the pixel is in the complex plane
    :param x: X coordinate of pixel
    :param y: Y coordinate of pixel
    :return: The a and be values of the complex number. In form of a + bi
    """
    a = x * intervalX + xMin
    b = yMax + (y * intervalY)
    return a, b


def calculate(z, c, step) -> int:
    """
    Does the actual recursive calculation to see if the pixel is in the Mandelbrot set.
    Uses the equation f(x) = z^2 + c
    It will automatically FOIL and combine like terms, and find the result of the equation
    :param z: The z value. A complex number
    :param c: The c value. A complex number
    :param step: The current iteration of the equation. Used to determine if it is in the set
    :return: -1 if it is in the set, or how many iterations it takes to get out of the set
    """
    if math.sqrt(math.pow(z[0], 2) + math.pow(z[1], 2)) > 2:
        return step
    elif step == 50:
        return -1
    else:
        newZ = (math.pow(z[0], 2) + -1 * math.pow(z[1], 2) + c[0], 2 * z[0] * z[1] + c[1])
        global iterations
        iterations += 1
        return calculate(newZ, c, step + 1)


def startCalculation(c) -> tuple:
    # print("Starting Calculation for " + x + " " + y)
    result = calculate((0, 0), c, 0)
    if result == -1:
        # print("making black")
        return black
    elif result > 50:
        # print("making blue")
        return purple
    elif result > 35:
        return maroon
    elif result > 25:
        return red
    elif result > 20:
        return orange
    elif result > 17:
        return 255, 255, 0
    else:
        return 0, 30 - 30 * result, 153 + 8 * result
main()

"""
Old methods that I may need in the future
def splitCalc(x, y, dim) -> Image:
    if dim == 1:
        result = calculate(0, getC(x, y))
        color = None
        if result == -1:
            # print("making black")
            color = black
        elif result > 50:
            # print("making blue")
            color = maroon
        elif result > 35:
            color = red
        elif result > 25:
            color = orange
        elif result > 15:
            color = (255, 255, 0)
        else:
            color = (0, 30 - 30 * result, 153 + 8 * result)
        im = Image.new('RGB', (1, 1))
        draw = ImageDraw.Draw(im, 'RGB')
        draw.point((x, y), color)
        del draw
        return im
    else:
        im = Image.new('RGB', (dim, dim))
        im.paste(splitCalc((0, 0), dim/2), (0, 0, dim/2, dim/2))

def startCalculation(x, y) -> tuple:
    #print("Starting Calculation for " + x + " " + y)
    a = None
    b = None
    if x > xAxisOffset:
        a = (x - xAxisOffset) * intervalX
    else:
        a = -((xAxisOffset - x) * intervalX)
    if y <yAxisOffset:
        b = ((yAxisOffset - y) * intervalY)
    else:
        b = -(y - yAxisOffset) * intervalY
    result = calculate((0, 0), (a, b), 0)
    if result == -1:
        #print("making black")
        return black
    elif result > 50:
        #print("making blue")
        return maroon
    elif result > 35:
        return red
    elif result > 25:
        return orange
    elif result > 15:
        return (255, 255, 0)
    else:
        return (0, 30 - 30 * result, 153 + 8 * result)
"""

